# CVE-2019-11683 Postmortem

## Summary

udp_gro_receive_segment in net/ipv4/udp_offload.c in the Linux kernel 5.x before 5.0.13 allows remote attackers to cause a denial of service (slab-out-of-bounds memory corruption) or possibly have unspecified other impact via UDP packets with a 0 payload, because of mishandling of padded packets, aka the "GRO packet of death" issue.

## Root Causes

```c
static struct sk_buff *udp_gro_receive_segment(struct list_head *head,
					       struct sk_buff *skb)
{
	struct udphdr *uh = udp_hdr(skb);
	struct sk_buff *pp = NULL;
	struct udphdr *uh2;
	struct sk_buff *p;
	unsigned int ulen;

// --snip--
	/* Do not deal with padded or malicious packets, sorry ! */
	ulen = ntohs(uh->len);           // <= The patch to fix it
	if (ulen <= sizeof(*uh) || ulen != skb_gro_len(skb)) { // <= The patch to fix it
		NAPI_GRO_CB(skb)->flush = 1; // <= The patch to fix it
		return NULL;                 // <= The patch to fix it
	}                                // <= The patch to fix it
// --snip--
		/* Terminate the flow on len mismatch or if it grow "too much".
		 * Under small packet flood GRO count could elsewhere grow a lot
		 * leading to excessive truesize values.
		 * On len mismatch merge the first packet shorter than gso_size,
		 * otherwise complete the GRO packet.
		 */
		if (ulen > ntohs(uh2->len) || skb_gro_receive(p, skb) || // <= Memory corruption in `skb_gro_receive`
		    ulen != ntohs(uh2->len) ||
		    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)
			pp = p;
```

## Resolution

xxx

## File

* net/ipv4/udp_offload.c

## Timeline

### 2019-05-01 18:56:28 -0700

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4dd2b82d5adfbe0b1587ccad7a8f76d826120f37

Fixed by Eric Dumazet.

## Supporting information

* CVE: https://www.cvedetails.com/cve/CVE-2019-11683/
* NVD: https://nvd.nist.gov/vuln/detail/CVE-2019-11683
